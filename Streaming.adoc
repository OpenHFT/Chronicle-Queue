= Chronicle Queue Streaming
Per Minborg
:css-signature: demo
:toc: macro
:toclevels: 2
:icons: font

toc::[]

== About Chronicle Queue Streaming

Chronicle Queue Streaming adds two different benefits to Chronicle Queue:

* Acting as a Stream Bridge between a Chronicle Queue and standard Java Streams.
* Maintaining Accumulation viws which are concurrent materialized views of Chronicle Queues.

Chronicle Queue Streaming is *an incubating feature* meaning it could be changed and even dropped in future releases.
Hence, running Chronicle Queue Streaming in production code is discouraged.

== Stream Bridge Overview

The Stream Bridge allows standard `java.util.stream.Stream` objects to be created directly from Chronicle Queues.
Here is an example how a Chronicle Queue that contains `MarketData` objects can be converted and used as a Stream:

[source,java]
----
String s = Streams.of(
               queue.createTailer(), <1>
               ofType(MarketData.class) <2>
         )
        .skip(100)
        .limit(50)
        .map(Object::toString)
        .collect(Collectors.joining(","));
----

<1> The `ExceprtTailer` to use when reading excerpts from the Queue.
The tailer can be set to a certain position before being submitted to the method above.

<2> The `ExcerptExtractor` used to convert an excerpt to an object.
In the example above an extractor of type `MarketData` is used obtained via the convenience function `ExcerptExtractor.ofType()`.

The `Stream` above exemplifies a pagination service where the third page of events is shown from the Queue (each page has 50 entries).
Once create, it behaves like any Stream and can take advantage of the whole Stream ecosystem.

The snippet above might produce the following output (shortened):
[source,text]

----
!net.openhft.chronicle.queue.incubator.streaming.demo.accumulation.MarketData {
  symbol: MSFT,
  last: 100.0,
  high: 110.0,
  low: 90.0
}
,!net.openhft.chronicle.queue.incubator.streaming.demo.accumulation.MarketData {
  symbol: APPL,
  last: 200.0,
  high: 220.0,
  low: 180.0
}
,!net.openhft.chronicle.queue.incubator.streaming.demo.accumulation.MarketData {
  symbol: MSFT,
  last: 101.0,
  high: 110.0,
  low: 90.0
}
...
----

== Accumulation Overview

An `Accumulation` allows access to continuously updated and concurrent view of an underlying Queue's content.
The `Accumulation` is maintained automatically.

Here is an example how an `Accumulation` that can be attached to a Chronicle Queue containing `MarketData` objects:

[source,java]
----
Accumulation<Map<String, MarketData>> accumulation = Accumulations.toMap(
        Accumulator.mapping(
                ofType(MarketData.class), <1>
                MarketData::symbol, <2>
                Function.identity(), <3>
                Accumulator.replacingMerger() <4>
        )
);

ChronicleQueue q = SingleChronicleQueueBuilder.builder()
                .path("market-data-queue")
                .appenderListener(accumulation) <5>
                .build()
----

<1> `ExcertpExtractor` that will extract objects of type `MarketData`.
<2> Classifier that will extract keys from `MarketData1 objects.
<3> Value extractor (in this case it will only pass through objects)
<4> Merger that will be applied on the old and new value if the key is already used.
<5> Register the accumulation with the queue so that it is automatically maintained when excerpts are added.

The `Accumulation` above exemplifies a latest-seen service where the latest `MarketData` per symbol (key) is maintained.

The `Accumulations.toMap()` takes an `Accumulator` that operates on Maps and that mapps objects of type `MarketData` using `MarketData::symbol` to extract keys and `Function.identity()` to extract values.
In case there is already a value associated with a particular key, the provided merger `Accumulator.replacingMerger()` is applied (which will replace the old existing value for a key with the new value).

Once an `Accumulation` is created, it can accept an `ExcerptTailer` to boostrap from an existing queue.
As shown above, it can also be registered with a Queue as an `AppenderListener` so that any updated made to the Queue also automatically will update the `Accumulation` effectively creating a "fire-and-forget" data structure.

The snippet above might produce the following output (shortened):
[source,text]

----
accumulation.accumulation() = {MSFT=!net.openhft.chronicle.queue.incubator.streaming.demo.accumulation.MarketData {
  symbol: MSFT,
  last: 101.0,
  high: 110.0,
  low: 90.0
}
, APPL=!net.openhft.chronicle.queue.incubator.streaming.demo.accumulation.MarketData {
  symbol: APPL,
  last: 200.0,
  high: 220.0,
  low: 180.0
}
}
----

== Stream Bridge

== Accumulation