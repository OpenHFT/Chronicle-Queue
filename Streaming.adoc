= Chronicle Queue Streaming
Per Minborg
:css-signature: demo
:toc: macro
:toclevels: 3
:icons: font

toc::[]

== About Chronicle Queue Streaming

Chronicle Queue Streaming adds two additional features to Chronicle Queue:

* Acting as a Stream Bridge between a Chronicle Queue and standard `java.util.stream.Stream` objects.
* Maintaining concurrent Reduction views which are materialized views of underlying Chronicle Queues.

Chronicle Queue Streaming is *an incubating feature* meaning it could be changed and even dropped in future releases. Hence, running Chronicle Queue Streaming in production code is discouraged.

== Stream Bridge Overview

The Stream Bridge allows standard `Stream`, `LongStream` and `DoubleStream` objects to be created directly from Chronicle Queues.
Here is an example how a Chronicle Queue that contains `MarketData` objects can be converted and used as a Stream:

[source,java]
----
String s = Streams.of(
               queue.createTailer(),                                <1>
               ExcerptExtractor.builder(MarketData.class).build()   <2>
         )
        .skip(100)
        .limit(50)
        .map(Object::toString)
        .collect(Collectors.joining(","));
----

<1> The `ExceprtTailer` to use when reading excerpts from the Queue.
The tailer can be set to a certain configuration and/or position before being submitted to the method above.

<2> The `ExcerptExtractor` used to convert an excerpt to a Java object.
In the example above, an extractor of type `MarketData` is used which is obtained via a builder function `ExcerptExtractor.builder()`.

The `Stream` above shows an example of a pagination service where the third page of events from the Queue is shown (each page has 50 rows).
Once the `Stream` is created, it behaves like any `Stream` and can take advantage of the whole `Stream` ecosystem.

The snippet above might produce the following output (shortened):
[source,text]

----
!MarketData {
  symbol: MSFT,
  last: 100.0,
  high: 110.0,
  low: 90.0
}
,!.MarketData {
  symbol: APPL,
  last: 200.0,
  high: 220.0,
  low: 180.0
}
,!MarketData {
  symbol: MSFT,
  last: 101.0,
  high: 110.0,
  low: 90.0
}
...
----

== Reduction Overview

A `Reduction` allows access to a continuously updated and concurrent view of an underlying Queue's content.
The `Reduction` can be maintained automatically.

Here is an example how a `Reduction` that can be attached to a Chronicle Queue containing `MarketData` objects:

[source,java]
----
Reduction<Map<String, MarketData>> latest = Reductions.of(
        ExcerptExtractor.builder(MarketData.class)
                .withMethod(MarketDataProvider.class, MarketDataProvider::marketData)
                .build(),             <1>
        Collectors.toConcurrentMap(   <2>
                MarketData::symbol,   <3>
                Function.identity(),  <4>
                replacingMerger()     <5>
        )
    );

ChronicleQueue q = SingleChronicleQueueBuilder.builder()
                .path("market-data-queue")
                .appenderListener(latest)     <6>
                .build()

MarketData latestAppleMarketData = latest.reduction().get("AAPL");  <7>

----

<1> `ExcertpExtractor` that will extract objects of type `MarketData` previously written via a method writer.
<2> A standard Java Collector which needs to be concurrent.
<3> Key extractor that will extract keys from `MarketData` objects.
<4> Value extractor (in this case, it will only pass through objects).
<5> Merger that will be applied on the old and new value if a key is already associated with an old value.
<6> Register the accumulation with the queue so that it is automatically maintained when excerpts are added.
<7> Example of how to access the concurrent reduction.

The `Reduction` above shows an example of a latest-seen service where the latest `MarketData` per symbol (key) is maintained.

The `Reductions.of()` takes an `ExcerptExtractor` that is used to extract objects from the queue and a standard Java Collector (which needs to be concurrent). The Collector shown above operates on Maps and, as described above, will map objects of type `MarketData` using `MarketData::symbol` to extract keys and `Function.identity()` to extract values.
In case there is already an old value associated with a particular key, the provided merger `Reductions.replacingMerger()` is applied (which will replace the old existing value for a key with the new value).

Once a `Reduction` is created, it can accept an `ExcerptTailer` to boostrap from an existing queue.
As shown above, it can also be registered with a Queue as an `ExcerptListener` so that any updates made to the Queue also automatically will update the `Reduction`, effectively creating a "fire-and-forget" data reduction structure.

The snippet above might produce the following output (shortened):

[source,text]
----
accumulation.accumulation() = {MSFT=!MarketData {
  symbol: MSFT,
  last: 101.0,
  high: 110.0,
  low: 90.0
}
, APPL=!MarketData {
  symbol: AAPL,
  last: 200.0,
  high: 220.0,
  low: 180.0
}
}
----

== Stream Bridge

This chapter contains a more detailed description of the Stream Bridge functionality.
First, a number of examples are shown so that the overall use cases can be more easily understood.
After that, a more formal description is presented.

=== Examples

This chapter contains a number of Stream Bridge examples.

==== LongStream: Finding the Highest Index

This example is using a `LongStream` eliminating object creation:

[source,java]
----
long last = Streams.ofLong(
                q.createTailer(),
                ToLongExcerptExtractor.extractingIndex() <1>
         )
        .max()
        .orElse(-1);                                     <2>

----

<1> Convenience method equivalent to `(wire, index) -> index`.
<2> If no index is present, return `-1`.

==== LongStream: Computing Statistics

This other example is also using a `LongStream` but with a custom extractor that will read a `long` directly from the queue.

[source,java]
----
LongSummaryStatistics stat = Streams.ofLong(
               q.createTailer(),
               (wire, index) -> wire.getValueIn().readLong() <1>
        )
        .summaryStatistics();
----

<1> Custom `ToLongExcerptExtractor` lambda.

==== Stream: Objects of a Certain Type

This example shows an example of creating a `Stream<MarketData>`.
[source,java]

----
Stream<MarketData> stream = Streams.of(queue.createTailer(), builder(MarketData.class).build());
----

The `ExcerptExtractor.builder(Class<E> type).build` construct is equivalent to:

[source,java]
----
(wire, index) -> wire
    .getValueIn()
    .object(type);
----

==== Stream: Objects from a Queue written via MethodWriters

If a queue was written using a method writer, the queue will likely contain messages of different types.
Assuming we have used a method writer implementing:

[source,java]
----
public interface Messages {

    void shares(Shares shares);

    void news(News news);

    void greeting(String greeting);

}
----

we can extract messages of a certain type like so:

[source,java]
----
List<News> newsList = Streams.of(
                    q.createTailer(),
                    builder(News.class)
                        .withMethod(Messages.class, Messages::news)
                        .build()                                           <1>
            )
            .sorted(Comparator.comparing(News::symbol))                    <2>
            .collect(toList());
----

<1> Creates an `ExcerptExtractor` that will extract `News` messages that was previously written to the queue using a method writer's `Messages::news` method.

<2> Standard `Stream` operation that will return a `Stream` sorted in `symbol` order.

The extractor will only extract messages of the specified type and method and not other messages.

==== Iterators and Spliterators

Streams, Spliterators and Iterators are related.
The Stream Bridge feature also supports creating various Spliterators and Iterators.
Here is an example:

[source,java]
----
Iterator<MarketData> iterator = Streams.iterator(
                queue.createTailer(),
                builder(MarketData.class).build()      <1>
);
----

<1> Extract messages of this type while iterating.

As can be seen, the procedure here is similar to creating a `Stream`.

==== Parallel Streams
Streams handle thread-safety issues with `ExcerptTailers` but in order to use parallel streams, the tailer's internal thread-safety checks must be turned off manually before parallel Streams are used:

[source,java]
----
ExcerptTailer tailer = q.createTailer().disableThreadSafetyCheck(true);
----

=== Constrains and Best Practices

This chapter contains tips for using the Stream Bridge feature.

==== Object Reuse

It is possible to create an `ExcerprExtractor` that is reusing objects.
Care must be taken if such an extractor is used so that, for example, reused objects are not exposed and/or not stored internally in the Streams pipeline.
If in doubt, make a copy or extract an immutable value from the object at hand.

[source,java]
----
OptionalDouble max = Streams.of(queue.createTailer(),
               builder(MarketData.class)
                        .withReusing(MarketData::new)    <1>
                        .build())
        .mapToDouble(MarketData::last)                   <2>
        .max();
----

<1> This supplier is used to provide objects that are reused when successively extracting a plurality of elements.
<2> A primitive `double` value is extracted directly making reuse safe.

Here is an example of object reuse that is *not allowed*:

[source,java]
----
List<MarketData> list = Streams.of(queue.createTailer(),
                builder(MarketData.class)
                        .withReusing(MarketData::new)  <1>
                        .build())
        .collect(toList());                            <2>

System.out.println("list = " + list);
----

<1> This supplier is used to provide objects that are reused when successively extracting a plurality of elements.
<2> As objects are reused, the list will be populated with identical objects that will reflect the latest value of the reused object.

This might print something like this:

[source,text]
----
list = [!MarketData {
  symbol: MSFT,
  last: 101.0,
  high: 110.0,
  low: 90.0
}
, !MarketData {
  symbol: MSFT,
  last: 101.0,
  high: 110.0,
  low: 90.0
}
, !MarketData {
  symbol: MSFT,
  last: 101.0,
  high: 110.0,
  low: 90.0
}
]
----

==== Closing an ExcerptTailer

In the examples above, an `ExcerptTailer` was created on demand but was not properly closed.
In memory sensitive applications, it is recommended that this is taken care of as tailers may have allocated internal resources.
Here is an example:

[source,java]
----
Map<String, List<MarketData>> groups;
try (ExcerptTailer tailer = queue.createTailer()) {
    groups = Streams.of(tailer, builder(MarketData.class).build())
            .collect(groupingBy(MarketData::symbol));
}    <1>

groups...
----

<1> The tailer is auto-closed here

==== GC and Object creation

Streams are likely to create objects during construction and use.
Therefore, the Stream Bridge features are not recommended in the same JVM as deterministic low-latency applications.
Once these objects are reclaimed by the Garbage Collector, jitter may be incurred on executing Threads.

=== Detailed Description

To Be Written...

== Reduction

=== Examples

This chapter contains a number of examples of how to use `Reduction` objects.

==== Counting Excerpts

[source,java]
----
Reduction<LongSupplier> counting = Reductions.counting() <1>
...
long count = counting.reduction().getAsLong();           <2>
----
<1> Maintains a count of the number of excerpts encountered.
<2> Shows how one can access the current reduction value.

==== Last Index Seen

This Accumulation will hold the latest index seen or 0 if no index was seen.

[source,java]
----
Reduction<LongSupplier> lastSeeing =
        Reductions.reducingLong(extractingIndex(), 0, (a, b) -> b); <1>
...
long lastSeen = lastSeeing.reduction().getAsLong();

----
<1> Maintains a view of the last index encountered or 0 if no index was encountered

==== Highest Index Seen

This Accumulation will hold the highest index seen or 0 if no index was seen.

[source,java]
----
Reduction<LongSupplier> maxIndexing =
        Reductions.reducingLong(extractingIndex(), 0L, Math::max); <1>
...
long maxIndex = maxIndexing.reduction().getAsLong();
----
<1> Maintains a view of the highest index encountered or 0 if no index was encountered.

==== Lowest Index Seen

This Accumulation will hold the lowest index seen or `Long.MAX_VALUE` if no index was seen.

[source,java]
----
Reduction<LongSupplier> minListener =
        Reductions.reducingLong(extractingIndex(), Long.MAX_VALUE, Math::min);
----

==== List of Elements

Maintains a List of all MarketData elements encountered in a List. This should be used with caution as a queue can contain many elements requiring a lot of heap memory.

[source,java]
----
Reduction<List<MarketData>> listing =
        Reductions.of(builder(MarketData.class).build(), ConcurrentCollectors.toConcurrentList()); <1>
----
<1> Maintains a List of all MarketData elements encountered in a List.

==== Set of Elements with Mapping and Filtering

Maintains a Set of all symbols that starts with an "S" in MarketData objects.

[source,java]
----
Reduction<Set<String>> symbolsStartingWithS = Reductions.of(
       builder(MarketData.class).withReusing(MarketData::new).build() <1>
                .map(MarketData::symbol)                              <2>
                .filter(s -> s.startsWith("S")),                      <3>
        ConcurrentCollectors.toConcurrentSet());                      <4>
----

<1> Extract MarketData objects.
<2> Map ExcerptExtractor<MarketData> to ExcerptExtractor<String> extracting symbols.
<3> Retain only symbols starting with "S".
<4> Collect to a concurrent Set.

==== Set of Elements with Object Reuse

Maintains a Set of all symbols in MarketData objects reusing intermediate MarketData objects.

[source,java]
----
Reduction<Set<String>> symbolsStartingWithS =
        Reduction.of(
                builder(MarketData.class)                       <1>
                    .withReusing(MarketData::new)               <2>
                    .build()
                .map(MarketData::symbol),                       <3>
               ConcurrentCollectors.toConcurrentSet());         <4>
----

<1> Extract MarketData objects.
<2> Provide a constructor used to create object(s) to reuse.
<3> Map ExcerptExtractor<MarketData> to ExcerptExtractor<String> extracting symbols.
<4> Collect to a concurrent Set.

NOTE: The reuse of object is safe in this case as immutable values are derived directly from the reused object.

==== Merging entries in a Map

Maintains a Map of the latest MarketData message per symbol where the messages were previously written by a MethodWriter of type MarketDataProvider. This is effectively a queue backed Map that will always reflect a state of the underlying queue.

[source,java]
----
Reduction<Map<String, MarketData>> latest = Reductions.of(
        ExcerptExtractor.builder(MarketData.class)
                .withMethod(MarketDataProvider.class, MarketDataProvider::marketData)
                .build(),
        Collectors.toConcurrentMap(
                MarketData::symbol,
                Function.identity(),
                replacingMerger()
        )
);
...
MarketData latestAppleMarketData = latest.reduction().get("AAPL");

Map<String, MarketData> liveQueueBackedMap = latest.reduction(); <1>

----
<1> This creates a live concurrent view of the reduction that can be invoked at any time.

==== Using a protected Reduction

Many collectors can be used in combination with a "protective coat" around the actuall reduction. Here is an example of providing an unmodifiable view of a map using standard Java Collector constructs:

[source,java]
----
Reduction<Map<String, MarketData>> latestProtected = Reductions.of(
        ExcerptExtractor.builder(MarketData.class)
                .withMethod(MarketDataProvider.class, MarketDataProvider::marketData)
                .build(),
        Collectors.collectingAndThen(
                Collectors.toConcurrentMap(
                        MarketData::symbol,
                        Function.identity(),
                        replacingMerger()),
                Collections::unmodifiableMap
        )
);
----


==== More Complex Reductions
As Collectors can be composed to an arbitrary depth, more complex reductions can easily be constructed. As long as the first-level collector is concurrent, the lower level ones need not be concurrent. Here is an example:
[source,java]
----
Reduction<ConcurrentMap<String, DoubleSummaryStatistics>> stats = Reductions.of(
        ExcerptExtractor.builder(MarketData.class)
                .withMethod(MarketDataProvider.class, MarketDataProvider::marketData)
                .build(),
        groupingByConcurrent(
                MarketData::symbol,
                summarizingDouble(MarketData::last)
        )
);
----
This will maintain statistics per symbol on `MarketData::last` using vanilla Java classes (creates objects).

==== Register with a Queue

A Reduction can be added to a Chronicle Queue using the `SingleChronicleQueueBuilder::appenderListener` method.
This means the Reduction will be automatically updated upon excerpts being persisted to the queue.

[source,java]
----
ChronicleQueue q = SingleChronicleQueueBuilder.builder()
        .path("my-queue")
        .appenderListener(reduction)
        .build();
----

==== Bootstrapping from a Tailer

Existing exerpts in a queue can be replayed onto an Reduction by means of the `Reduction::accept` method.
This provides an easy way to bootstrap the Reduction upon restart.

[source,java]
----
reduction.accept(queue.createTailer());
----

=== Detailed Description

To Be Written...

== To be Documented

* Configuration Accumulators (concrete classes)
* Parallel streams
* ExcerptExtractor.ofType() error handling (what if there is another message on the queue?)
* Extractors' use of `null` and `Long.MIN_VALUE`